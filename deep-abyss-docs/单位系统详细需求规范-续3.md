# 《深渊巢穴》单位系统详细需求规范（续3）

## 18. 附录

### 18.1 术语表

| 术语 | 定义 | 使用场景 | 相关概念 |
|-----|-----|---------|---------|
| 单位 | 游戏中可控制的生物实体 | 整个游戏系统 | 属性、能力、基因 |
| 基因 | 决定单位特性的基础元素 | 单位创建、进化 | 基因组、基因表达、基因突变 |
| 进化 | 单位形态和能力的升级过程 | 单位发展 | 进化路径、进化条件、进化阶段 |
| 能力 | 单位可执行的特殊行动 | 战斗、交互 | 能力冷却、能力效果、能力解锁 |
| 属性 | 定义单位基本特征的数值 | 单位状态计算 | 基础属性、衍生属性、属性上限 |
| 状态效果 | 临时影响单位的效果 | 战斗、环境交互 | 增益效果、减益效果、状态持续时间 |
| 行为树 | AI决策的层次结构 | 单位AI控制 | 选择节点、序列节点、条件节点 |
| 资源节点 | 可采集资源的环境实体 | 资源采集 | 资源类型、资源丰度、采集效率 |
| 环境区域 | 具有特定特性的地图区域 | 环境交互 | 环境效果、环境适应、环境改造 |
| 群体行为 | 多单位协同的行为模式 | 群体控制 | 群体协同、群体效率、群体共鸣 |
| 基因表达 | 基因对单位产生实际影响的过程 | 单位特性形成 | 显性特性、隐性特性、表达强度 |
| 深渊变异 | 在深渊环境中的特殊进化 | 特殊进化路径 | 不稳定性、深渊能量、变异风险 |
| 空间分区 | 优化单位管理的技术方法 | 性能优化 | 网格单元、位置更新、范围查询 |
| 交互系统 | 处理单位间互动的系统 | 单位社交、资源交换 | 交互类型、交互效果、交互条件 |
| 视觉表现 | 单位的外观和动画效果 | 游戏表现层 | 模型、动画、特效、材质 |

### 18.2 参考资料

#### 18.2.1 内部参考文档

| 文档名称 | 版本 | 作者 | 关联内容 | 位置 |
|---------|-----|-----|---------|-----|
| 《深渊巢穴》游戏设计文档 | v2.3 | 设计团队 | 游戏整体设计 | 项目文档库/设计/ |
| 基因系统详细需求规范 | v1.5 | 系统设计组 | 基因系统设计 | 项目文档库/系统/ |
| 环境系统详细需求规范 | v1.2 | 系统设计组 | 环境交互设计 | 项目文档库/系统/ |
| 战斗系统详细需求规范 | v1.3 | 系统设计组 | 战斗机制设计 | 项目文档库/系统/ |
| 资源系统详细需求规范 | v1.1 | 系统设计组 | 资源机制设计 | 项目文档库/系统/ |
| 单位系统技术原型报告 | v0.8 | 程序团队 | 技术可行性验证 | 项目文档库/技术/ |
| 单位美术风格指南 | v1.4 | 美术团队 | 视觉设计标准 | 项目文档库/美术/ |

#### 18.2.2 外部参考资料

| 资料名称 | 作者/出版社 | 年份 | 参考内容 | 影响 |
|---------|------------|-----|---------|-----|
| 《游戏AI编程智慧》 | Matt Buckland | 2018 | 行为树设计 | AI系统架构 |
| 《游戏编程模式》 | Robert Nystrom | 2014 | 对象池模式 | 性能优化方案 |
| 《进化生物学原理》 | Douglas J. Futuyma | 2017 | 进化理论 | 进化系统设计 |
| 《分子生物学基础》 | Robert F. Weaver | 2019 | 基因概念 | 基因系统设计 |
| 《游戏平衡性设计》 | Ian Schreiber | 2017 | 数值平衡 | 单位属性设计 |
| 《Unity高级游戏开发》 | Alan Thorn | 2020 | 技术实现 | 系统架构设计 |
| 《生物形态学》 | D'Arcy Thompson | 2016 | 生物形态 | 视觉设计参考 |

### 18.3 修订历史

| 版本 | 日期 | 修订人 | 审核人 | 主要变更 |
|-----|-----|------|------|---------|
| v0.1 | 2023-01-15 | 张明 | - | 初始草稿，基本框架 |
| v0.2 | 2023-01-30 | 张明 | 李华 | 添加单位属性系统 |
| v0.3 | 2023-02-15 | 王强 | 李华 | 添加能力系统设计 |
| v0.4 | 2023-03-01 | 张明 | 李华 | 添加进化系统设计 |
| v0.5 | 2023-03-20 | 刘芳 | 李华 | 添加视觉表现系统 |
| v0.6 | 2023-04-10 | 王强 | 李华 | 添加交互系统设计 |
| v0.7 | 2023-05-05 | 张明 | 李华 | 添加技术实现部分 |
| v0.8 | 2023-05-25 | 刘芳 | 李华 | 添加测试规范 |
| v0.9 | 2023-06-15 | 王强 | 李华 | 添加系统交互设计 |
| v1.0 | 2023-07-01 | 张明 | 陈总 | 首个完整版本 |
| v1.1 | 2023-08-10 | 刘芳 | 陈总 | 更新进化路径设计 |
| v1.2 | 2023-09-20 | 王强 | 陈总 | 更新AI系统设计 |
| v1.3 | 2023-11-05 | 张明 | 陈总 | 更新性能优化方案 |
| v1.4 | 2024-01-15 | 刘芳 | 陈总 | 更新美术资源需求 |
| v1.5 | 2024-03-01 | 王强 | 陈总 | 当前版本，更新发布计划 |

### 18.4 单位系统数值表

#### 18.4.1 基础单位属性表

| 单位类型 | 生命值 | 能量值 | 移动速度 | 攻击力 | 防御力 | 视野范围 | 资源容量 |
|---------|------|------|---------|------|------|---------|---------|
| 采集单位 | 100 | 80 | 3.5 | 10 | 15 | 12 | 50 |
| 建设单位 | 120 | 100 | 3.0 | 15 | 20 | 10 | 30 |
| 近战单位 | 150 | 90 | 4.0 | 35 | 25 | 8 | 10 |
| 远程单位 | 90 | 110 | 3.8 | 30 | 15 | 15 | 10 |
| 防御单位 | 200 | 80 | 2.5 | 20 | 40 | 9 | 15 |
| 控制单位 | 110 | 150 | 3.2 | 15 | 20 | 12 | 10 |
| 治疗单位 | 100 | 130 | 3.3 | 10 | 15 | 11 | 10 |
| 基因工程师 | 120 | 180 | 3.0 | 20 | 20 | 14 | 20 |
| 虚空行者 | 130 | 200 | 4.5 | 25 | 15 | 18 | 15 |
| 同化者 | 140 | 160 | 3.7 | 30 | 25 | 13 | 10 |
| 先驱者 | 150 | 190 | 3.5 | 25 | 30 | 16 | 25 |
| 深渊主宰 | 300 | 250 | 4.0 | 50 | 50 | 20 | 50 |

#### 18.4.2 进化属性提升表

| 进化阶段 | 生命值提升 | 能量值提升 | 移动速度提升 | 攻击力提升 | 防御力提升 | 视野提升 | 资源容量提升 |
|---------|----------|----------|------------|----------|----------|---------|------------|
| 初始→中级 | +30% | +30% | +20% | +30% | +30% | +15% | +25% |
| 中级→高级 | +50% | +50% | +30% | +50% | +50% | +25% | +40% |
| 高级→精英 | +100% | +100% | +50% | +100% | +100% | +40% | +60% |

#### 18.4.3 基因影响系数表

| 基因类型 | 生命值 | 能量值 | 移动速度 | 攻击力 | 防御力 | 特殊效果 |
|---------|------|------|---------|------|------|---------|
| 酸性基因 | -10% | +5% | +10% | +20% | -15% | 腐蚀伤害 |
| 碱性基因 | +10% | -5% | -5% | -10% | +25% | 净化效果 |
| 金属基因 | +15% | -10% | -15% | +5% | +30% | 物理反弹 |
| 有机基因 | +20% | +10% | +5% | 0% | -5% | 生命恢复 |
| 能量基因 | -5% | +30% | +15% | +15% | -10% | 能量爆发 |
| 虚空基因 | -15% | +20% | +20% | +10% | -20% | 空间扭曲 |
| 原始基因 | +5% | +5% | +5% | +5% | +5% | 适应性强 |
| 合成基因 | 0% | +15% | +10% | +10% | +10% | 精确控制 |

### 18.5 单位能力详细说明

#### 18.5.1 基础能力详细参数

| 能力名称 | 能量消耗 | 冷却时间(秒) | 作用范围(米) | 持续时间(秒) | 效果数值 | 解锁条件 |
|---------|---------|------------|-----------|------------|---------|---------|
| 快速采集 | 20 | 30 | 自身 | 15 | 采集速度+50% | 采集单位默认 |
| 修复结构 | 30 | 45 | 5 | 即时 | 修复100点结构生命值 | 建设单位默认 |
| 冲锋打击 | 25 | 20 | 8 | 即时 | 伤害+30%，击退2米 | 近战单位默认 |
| 精准射击 | 20 | 25 | 12 | 即时 | 伤害+40%，无视20%防御 | 远程单位默认 |
| 防御姿态 | 15 | 40 | 自身 | 20 | 防御+50%，移动速度-30% | 防御单位默认 |
| 思维控制 | 40 | 60 | 8 | 10 | 控制目标行动 | 控制单位默认 |
| 生命注入 | 35 | 45 | 6 | 即时 | 恢复目标30%生命值 | 治疗单位默认 |
| 基因分析 | 30 | 90 | 10 | 即时 | 显示目标基因组成 | 基因工程师默认 |
| 虚空跃迁 | 50 | 120 | 15 | 即时 | 瞬间移动到目标位置 | 虚空行者默认 |
| 同化触须 | 45 | 100 | 6 | 8 | 持续伤害并吸取生命值 | 同化者默认 |
| 环境感知 | 25 | 60 | 20 | 30 | 显示范围内所有单位 | 先驱者默认 |
| 深渊召唤 | 100 | 300 | 15 | 60 | 召唤3个深渊生物 | 深渊主宰默认 |

#### 18.5.2 高级能力详细参数

| 能力名称 | 能量消耗 | 冷却时间(秒) | 作用范围(米) | 持续时间(秒) | 效果数值 | 解锁条件 |
|---------|---------|------------|-----------|------------|---------|---------|
| 资源转化 | 40 | 120 | 自身 | 即时 | 转化资源类型 | 采集单位中级进化 |
| 快速建造 | 50 | 180 | 10 | 30 | 建造速度+100% | 建设单位中级进化 |
| 旋风打击 | 60 | 90 | 5 | 3 | 范围伤害，每秒20点 | 近战单位中级进化 |
| 穿透射击 | 55 | 100 | 20 | 即时 | 穿透多个目标 | 远程单位中级进化 |
| 能量屏障 | 70 | 150 | 8 | 15 | 创建防御屏障，吸收200伤害 | 防御单位中级进化 |
| 群体混乱 | 80 | 200 | 12 | 8 | 使范围内敌人互相攻击 | 控制单位中级进化 |
| 生命爆发 | 75 | 180 | 10 | 即时 | 范围内友军恢复50%生命值 | 治疗单位中级进化 |
| 基因注入 | 90 | 240 | 8 | 即时 | 临时赋予目标新基因特性 | 基因工程师高级进化 |
| 虚空风暴 | 100 | 300 | 15 | 12 | 范围伤害，扭曲空间 | 虚空行者高级进化 |
| 完全控制 | 120 | 360 | 10 | 20 | 完全控制目标单位 | 同化者高级进化 |
| 环境调节 | 110 | 300 | 25 | 60 | 改变区域环境类型 | 先驱者高级进化 |
| 深渊之门 | 200 | 600 | 30 | 120 | 创建通往深渊的传送门 | 深渊主宰精英进化 |

### 18.6 单位进化路径图

```
采集单位进化路径:
原始采集者 → 高级采集者 → 资源专家 → 物质操控者
           ↘ 探矿者 → 元素提取者 → 元素支配者

建设单位进化路径:
基础建设者 → 构造师 → 建筑大师 → 创世工匠
           ↘ 防御工程师 → 堡垒建造者 → 要塞架构师

近战单位进化路径:
突击者 → 狂战士 → 毁灭者 → 深渊屠夫
       ↘ 刺客 → 暗影猎手 → 虚空刺客
       ↘ 护卫 → 守护武士 → 永恒守护者

远程单位进化路径:
射手 → 狙击手 → 风暴弓手 → 虚空猎手
     ↘ 炮手 → 轰炸专家 → 毁灭炮手
     ↘ 能量射手 → 能量操控者 → 能量主宰

防御单位进化路径:
防御者 → 守护者 → 不朽壁垒 → 永恒堡垒
       ↘ 反射者 → 能量屏障 → 绝对防御
       ↘ 吸收者 → 伤害转化者 → 能量转换堡垒

控制单位进化路径:
控制者 → 支配者 → 思维主宰 → 意志统御者
       ↘ 幻术师 → 现实扭曲者 → 维度操控者
       ↘ 协调者 → 群体意识 → 集体思维

治疗单位进化路径:
治疗者 → 生命使者 → 复苏大师 → 永生编织者
       ↘ 净化者 → 腐化驱除者 → 纯净守护者
       ↘ 生命操控者 → 基因医师 → 生命创造者
```

### 18.7 单位系统接口定义

#### 18.7.1 核心接口

```csharp
// 单位接口
public interface IUnit
{
    string ID { get; }
    string Name { get; set; }
    UnitType Type { get; }
    UnitRank Rank { get; }
    int EvolutionStage { get; }
    
    // 属性相关
    float GetAttribute(string attributeName);
    void SetBaseAttribute(string attributeName, float value);
    float CalculateEffectiveAttribute(string attributeName);
    
    // 状态相关
    bool IsAlive { get; }
    bool CanAct { get; }
    void TakeDamage(int amount, DamageType type, IUnit source);
    void Heal(int amount, IUnit source);
    
    // 能力相关
    List<IAbility> GetAbilities();
    bool UseAbility(int abilityIndex, Vector3 targetPosition, IUnit targetUnit);
    bool HasAbility(string abilityID);
    void AddAbility(IAbility ability);
    void RemoveAbility(string abilityID);
    
    // 基因相关
    List<IGene> GetGenes();
    void AddGene(IGene gene);
    void RemoveGene(string geneID);
    GeneType GetDominantGeneType();
    
    // 进化相关
    bool CanEvolve();
    List<EvolutionOption> GetEvolutionOptions();
    bool EvolveTo(string evolutionPathID);
    
    // 行为相关
    void SetBehavior(IBehaviorTree behaviorTree);
    void UpdateBehavior(float deltaTime);
    void SetTask(ITask task);
    
    // 资源相关
    int GetResourceAmount(ResourceType type);
    bool AddResource(ResourceType type, int amount);
    bool RemoveResource(ResourceType type, int amount);
    int GetResourceCapacity();
    
    // 视觉相关
    void UpdateVisuals();
    void PlayAnimation(string animationName, bool loop);
    void AttachEffect(string effectPrefabID, string attachPointID);
    
    // 事件
    event Action<IUnit> OnDeath;
    event Action<IUnit, IUnit> OnAttack;
    event Action<IUnit, IAbility> OnAbilityUsed;
    event Action<IUnit, IGene> OnGeneAdded;
    event Action<IUnit, string> OnEvolution;
}

// 能力接口
public interface IAbility
{
    string ID { get; }
    string Name { get; }
    AbilityType Type { get; }
    int EnergyCost { get; }
    float Cooldown { get; }
    float CurrentCooldown { get; }
    float Range { get; }
    float Duration { get; }
    
    bool CanUse(IUnit caster);
    void Use(IUnit caster, Vector3 targetPosition, IUnit targetUnit);
    void UpdateCooldown(float deltaTime);
    string GetDescription();
    List<AbilityEffect> GetEffects();
}

// 基因接口
public interface IGene
{
    string ID { get; }
    string Name { get; }
    GeneType Type { get; }
    float Stability { get; }
    
    float GetAttributeModifier(string attributeName);
    float GetDamageResistance(DamageType damageType);
    List<GeneTrait> GetTraits();
    bool HasTrait(string traitID);
    void AddTrait(GeneTrait trait);
    void RemoveTrait(string traitID);
    GeneVisualData GetVisualData();
}

// 行为树接口
public interface IBehaviorTree
{
    IBehaviorNode RootNode { get; }
    IUnit Owner { get; }
    
    BehaviorStatus Execute();
    void SetRootNode(IBehaviorNode node);
    void AddData(string key, object value);
    T GetData<T>(string key);
}

// 状态效果接口
public interface IStatusEffect
{
    string ID { get; }
    string Name { get; }
    StatusEffectType Type { get; }
    float Duration { get; }
    float RemainingTime { get; }
    
    void Apply(IUnit target);
    void Remove(IUnit target);
    void Tick(float deltaTime, IUnit target);
    Dictionary<string, float> GetAttributeModifiers();
    string GetDescription();
}
```

#### 18.7.2 管理器接口

```csharp
// 单位管理器接口
public interface IUnitManager
{
    IUnit CreateUnit(UnitType type, Vector3 position, Quaternion rotation);
    void DestroyUnit(IUnit unit);
    List<IUnit> GetAllUnits();
    List<IUnit> GetUnitsOfType(UnitType type);
    List<IUnit> GetUnitsInRange(Vector3 position, float range);
    IUnit GetUnitByID(string unitID);
    int GetActiveUnitCount();
    void UpdateUnits(float deltaTime);
}

// 能力管理器接口
public interface IAbilityManager
{
    IAbility CreateAbility(string abilityID);
    List<IAbility> GetAbilitiesForUnitType(UnitType type);
    List<IAbility> GetAbilitiesForEvolutionStage(UnitType type, int evolutionStage);
    IAbility GetAbilityByID(string abilityID);
    void RegisterAbilityTemplate(AbilityTemplate template);
}

// 基因管理器接口
public interface IGeneManager
{
    IGene CreateGene(GeneType type);
    IGene CreateRandomGene();
    IGene FuseGenes(IGene geneA, IGene geneB, float stabilityFactor);
    GeneTrait GetTraitByID(string traitID);
    List<GeneTrait> GetTraitsForGeneType(GeneType type);
    void RegisterGeneTrait(GeneTrait trait);
}

// 进化管理器接口
public interface IEvolutionManager
{
    List<EvolutionPath> GetEvolutionPathsForUnit(IUnit unit);
    bool CanUnitEvolve(IUnit unit, string evolutionPathID);
    EvolutionResult EvolveUnit(IUnit unit, string evolutionPathID);
    void RegisterEvolutionPath(EvolutionPath path);
    EvolutionPath GetEvolutionPathByID(string pathID);
}
```

### 18.8 单位系统测试用例示例

#### 18.8.1 单元测试用例

```csharp
[TestFixture]
public class UnitAttributeTests
{
    private Unit testUnit;
    
    [SetUp]
    public void Setup()
    {
        // 创建测试单位
        testUnit = new Unit();
        testUnit.SetBaseAttribute("health", 100);
        testUnit.SetBaseAttribute("energy", 100);
        testUnit.SetBaseAttribute("attackPower", 20);
        testUnit.SetBaseAttribute("defense", 10);
    }
    
    [Test]
    public void TestBaseAttributes()
    {
        // 测试基础属性是否正确设置
        Assert.AreEqual(100, testUnit.GetAttribute("health"));
        Assert.AreEqual(100, testUnit.GetAttribute("energy"));
        Assert.AreEqual(20, testUnit.GetAttribute("attackPower"));
        Assert.AreEqual(10, testUnit.GetAttribute("defense"));
    }
    
    [Test]
    public void TestGeneAttributeModifiers()
    {
        // 创建测试基因
        Gene testGene = new Gene();
        testGene.SetAttributeModifier("attackPower", 1.5f); // +50%攻击力
        testGene.SetAttributeModifier("defense", 0.8f); // -20%防御力
        
        // 添加基因到单位
        testUnit.AddGene(testGene);
        
        // 测试基因是否正确修改属性
        Assert.AreEqual(30, testUnit.CalculateEffectiveAttribute("attackPower")); // 20 * 1.5 = 30
        Assert.AreEqual(8, testUnit.CalculateEffectiveAttribute("defense")); // 10 * 0.8 = 8
    }
    
    [Test]
    public void TestStatusEffectAttributeModifiers()
    {
        // 创建测试状态效果
        StatusEffect testEffect = new StatusEffect();
        testEffect.AddAttributeModifier("attackPower", 1.2f); // +20%攻击力
        testEffect.AddAttributeModifier("moveSpeed", 0.7f); // -30%移动速度
        
        // 应用状态效果
        testUnit.ApplyStatusEffect(testEffect);
        
        // 测试状态效果是否正确修改属性
        Assert.AreEqual(24, testUnit.CalculateEffectiveAttribute("attackPower")); // 20 * 1.2 = 24
        Assert.AreEqual(2.8f, testUnit.CalculateEffectiveAttribute("moveSpeed")); // 4.0 * 0.7 = 2.8
    }
    
    [Test]
    public void TestCombinedAttributeModifiers()
    {
        // 创建测试基因
        Gene testGene = new Gene();
        testGene.SetAttributeModifier("attackPower", 1.5f); // +50%攻击力
        
        // 创建测试状态效果
        StatusEffect testEffect = new StatusEffect();
        testEffect.AddAttributeModifier("attackPower", 1.2f); // +20%攻击力
        
        // 添加基因和状态效果
        testUnit.AddGene(testGene);
        testUnit.ApplyStatusEffect(testEffect);
        
        // 测试组合修改是否正确
        // 20(基础) * 1.5(基因) * 1.2(状态) = 36
        Assert.AreEqual(36, testUnit.CalculateEffectiveAttribute("attackPower"));
    }
    
    [Test]
    public void TestDamageCalculation()
    {
        // 设置初始生命值
        testUnit.SetCurrentHealth(100);
        
        // 创建伤害来源
        Unit attacker = new Unit();
        attacker.SetBaseAttribute("attackPower", 30);
        
        // 测试物理伤害计算
        testUnit.TakeDamage(30, DamageType.Physical, attacker);
        
        // 预期伤害: 30 * (1 - 10/(10+100)) = 30 * 0.9 = 27
        // 预期剩余生命值: 100 - 27 = 73
        Assert.AreEqual(73, testUnit.GetCurrentHealth());
    }
}

[TestFixture]
public class UnitEvolutionTests
{
    private Unit testUnit;
    private EvolutionManager evolutionManager;
    
    [SetUp]
    public void Setup()
    {
        // 初始化进化管理器
        evolutionManager = new EvolutionManager();
        
        // 注册测试进化路径
        EvolutionPath testPath = new EvolutionPath();
        testPath.ID = "test_path";
        testPath.SourceType = UnitType.Collector;
        testPath.TargetType = UnitType.ResourceExpert;
        testPath.RequiredEvolutionStage = 1;
        testPath.AddRequirement(new ExperienceRequirement(100));
        evolutionManager.RegisterEvolutionPath(testPath);
        
        // 创建测试单位
        testUnit = new Unit();
        testUnit.Type = UnitType.Collector;
        testUnit.EvolutionStage = 1;
        testUnit.Experience = 120; // 满足经验要求
    }
    
    [Test]
    public void TestEvolutionEligibility()
    {
        // 测试单位是否有资格进化
        bool canEvolve = evolutionManager.CanUnitEvolve(testUnit, "test_path");
        Assert.IsTrue(canEvolve);
        
        // 测试经验不足的情况
        testUnit.Experience = 80;
        canEvolve = evolutionManager.CanUnitEvolve(testUnit, "test_path");
        Assert.IsFalse(canEvolve);
    }
    
    [Test]
    public void TestEvolutionProcess()
    {
        // 确保单位满足进化条件
        testUnit.Experience = 120;
        
        // 执行进化
        EvolutionResult result = evolutionManager.EvolveUnit(testUnit, "test_path");
        
        // 验证进化结果
        Assert.IsTrue(result.Success);
        Assert.AreEqual(UnitType.ResourceExpert, testUnit.Type);
        Assert.AreEqual(2, testUnit.EvolutionStage);
        
        // 验证属性提升
        // 假设进化会提升攻击力50%
        float attackBefore = 20;
        testUnit.SetBaseAttribute("attackPower", attackBefore);
        float expectedAttackAfter = attackBefore * 1.5f;
        Assert.AreEqual(expectedAttackAfter, testUnit.GetAttribute("attackPower"));
    }
    
    [Test]
    public void TestInvalidEvolutionPath()
    {
        // 测试无效的进化路径
        EvolutionResult result = evolutionManager.EvolveUnit(testUnit, "invalid_path");
        
        // 验证进化失败
        Assert.IsFalse(result.Success);
        Assert.AreEqual(UnitType.Collector, testUnit.Type); // 类型未变
        Assert.AreEqual(1, testUnit.EvolutionStage); // 进化阶段未变
    }
}

[TestFixture]
public class UnitAbilityTests
{
    private Unit testUnit;
    private Ability testAbility;
    
    [SetUp]
    public void Setup()
    {
        // 创建测试单位
        testUnit = new Unit();
        testUnit.SetBaseAttribute("energy", 100);
        
        // 创建测试能力
        testAbility = new Ability();
        testAbility.ID = "test_ability";
        testAbility.Name = "测试能力";
        testAbility.EnergyCost = 30;
        testAbility.Cooldown = 10;
        testAbility.Range = 5;
        
        // 添加能力到单位
        testUnit.AddAbility(testAbility);
    }
    
    [Test]
    public void TestAbilityUsage()
    {
        // 测试能力使用
        bool useResult = testUnit.UseAbility(0, Vector3.zero, null);
        
        // 验证能力使用成功
        Assert.IsTrue(useResult);
        
        // 验证能量消耗
        Assert.AreEqual(70, testUnit.GetAttribute("energy")); // 100 - 30 = 70
        
        // 验证冷却时间
        Assert.AreEqual(10, testAbility.CurrentCooldown);
    }
    
    [Test]
    public void TestAbilityCooldown()
    {
        // 使用能力
        testUnit.UseAbility(0, Vector3.zero, null);
        
        // 尝试在冷却中再次使用
        bool useResult = testUnit.UseAbility(0, Vector3.zero, null);
        
        // 验证使用失败
        Assert.IsFalse(useResult);
        
        // 模拟冷却时间流逝
        testAbility.UpdateCooldown(5);
        Assert.AreEqual(5, testAbility.CurrentCooldown);
        
        // 冷却未完成，仍然无法使用
        useResult = testUnit.UseAbility(0, Vector3.zero, null);
        Assert.IsFalse(useResult);
        
        // 完成冷却
        testAbility.UpdateCooldown(5);
        Assert.AreEqual(0, testAbility.CurrentCooldown);
        
        // 现在可以使用了
        useResult = testUnit.UseAbility(0, Vector3.zero, null);
        Assert.IsTrue(useResult);
    }
    
    [Test]
    public void TestAbilityRange()
    {
        // 创建目标单位，在范围外
        Unit targetUnit = new Unit();
        targetUnit.transform.position = new Vector3(10, 0, 0); // 距离为10，超出范围5
        
        // 尝试对范围外目标使用能力
        bool useResult = testUnit.UseAbility(0, targetUnit.transform.position, targetUnit);
        
        // 验证使用失败
        Assert.IsFalse(useResult);
        
        // 移动目标到范围内
        targetUnit.transform.position = new Vector3(3, 0, 0); // 距离为3，在范围5内
        
        // 再次尝试使用能力
        useResult = testUnit.UseAbility(0, targetUnit.transform.position, targetUnit);
        
        // 验证使用成功
        Assert.IsTrue(useResult);
    }
}
```

#### 18.8.2 集成测试用例

```csharp
[TestFixture]
public class UnitSystemIntegrationTests
{
    private UnitManager unitManager;
    private GeneManager geneManager;
    private AbilityManager abilityManager;
    private EvolutionManager evolutionManager;
    private ResourceManager resourceManager;
    
    [SetUp]
    public void Setup()
    {
        // 初始化各个管理器
        unitManager = new UnitManager();
        geneManager = new GeneManager();
        abilityManager = new AbilityManager();
        evolutionManager = new EvolutionManager();
        resourceManager = new ResourceManager();
        
        // 注册必要的模板和路径
        RegisterTestTemplates();
    }
    
    private void RegisterTestTemplates()
    {
        // 注册单位模板
        UnitTemplate collectorTemplate = new UnitTemplate();
        collectorTemplate.Type = UnitType.Collector;
        collectorTemplate.BaseAttributes.Add("health", 100);
        collectorTemplate.BaseAttributes.Add("energy", 80);
        collectorTemplate.BaseAttributes.Add("moveSpeed", 3.5f);
        unitManager.RegisterUnitTemplate(collectorTemplate);
        
        // 注册能力模板
        AbilityTemplate fastCollectTemplate = new AbilityTemplate();
        fastCollectTemplate.ID = "fast_collect";
        fastCollectTemplate.Name = "快速采集";
        fastCollectTemplate.EnergyCost = 20;
        fastCollectTemplate.Cooldown = 30;
        abilityManager.RegisterAbilityTemplate(fastCollectTemplate);
        
        // 注册基因特性
        GeneTrait efficientTrait = new GeneTrait();
        efficientTrait.ID = "efficient_collection";
        efficientTrait.Name = "高效采集";
        efficientTrait.AddAttributeModifier("collectionSpeed", 1.3f);
        geneManager.RegisterGeneTrait(efficientTrait);
        
        // 注册进化路径
        EvolutionPath collectorEvolution = new EvolutionPath();
        collectorEvolution.ID = "collector_to_expert";
        collectorEvolution.SourceType = UnitType.Collector;
        collectorEvolution.TargetType = UnitType.ResourceExpert;
        collectorEvolution.RequiredEvolutionStage = 1;
        evolutionManager.RegisterEvolutionPath(collectorEvolution);
    }
    
    [Test]
    public void TestCompleteUnitLifecycle()
    {
        // 创建单位
        IUnit collector = unitManager.CreateUnit(UnitType.Collector, Vector3.zero, Quaternion.identity);
        
        // 验证单位创建成功
        Assert.IsNotNull(collector);
        Assert.AreEqual(UnitType.Collector, collector.Type);
        
        // 添加基因
        IGene organicGene = geneManager.CreateGene(GeneType.Organic);
        collector.AddGene(organicGene);
        
        // 验证基因添加成功
        Assert.AreEqual(1, collector.GetGenes().Count);
        Assert.AreEqual(GeneType.Organic, collector.GetGenes()[0].Type);
        
        // 使用能力
        IAbility fastCollect = abilityManager.CreateAbility("fast_collect");
        collector.AddAbility(fastCollect);
        bool useResult = collector.UseAbility(0, Vector3.zero, null);
        
        // 验证能力使用成功
        Assert.IsTrue(useResult);
        
        // 采集资源
        ResourceNode resourceNode = new ResourceNode();
        resourceNode.Type = ResourceType.Biomass;
        resourceNode.Amount = 50;
        
        collector.CollectResource(resourceNode);
        
        // 验证资源采集成功
        Assert.AreEqual(50, collector.GetResourceAmount(ResourceType.Biomass));
        
        // 进化单位
        collector.SetExperience(100); // 设置足够的经验
        EvolutionResult evolveResult = evolutionManager.EvolveUnit(collector, "collector_to_expert");
        
        // 验证进化成功
        Assert.IsTrue(evolveResult.Success);
        Assert.AreEqual(UnitType.ResourceExpert, collector.Type);
        
        // 战斗测试
        IUnit enemy = unitManager.CreateUnit(UnitType.Assaulter, new Vector3(3, 0, 0), Quaternion.identity);
        enemy.SetBaseAttribute("attackPower", 20);
        
        int initialHealth = (int)collector.GetAttribute("health");
        enemy.Attack(collector);
        
        // 验证战斗结果
        Assert.Less(collector.GetAttribute("health"), initialHealth);
        
        // 死亡测试
        bool deathEventTriggered = false;
        collector.OnDeath += (unit) => { deathEventTriggered = true; };
        
        // 造成致命伤害
        collector.TakeDamage(1000, DamageType.Pure, enemy);
        
        // 验证死亡事件触发
        Assert.IsTrue(deathEventTriggered);
        Assert.IsFalse(collector.IsAlive);
    }
    
    [Test]
    public void TestUnitGroupBehavior()
    {
        // 创建一组单位
        List<IUnit> unitGroup = new List<IUnit>();
        for (int i = 0; i < 5; i++)
        {
            IUnit unit = unitManager.CreateUnit(UnitType.Collector, new Vector3(i, 0, 0), Quaternion.identity);
            unitGroup.Add(unit);
        }
        
        // 创建群体行为
        GroupBehavior groupBehavior = new GroupBehavior(unitGroup);
        Vector3 targetPosition = new Vector3(10, 0, 10);
        groupBehavior.MoveToPosition(targetPosition);
        
        // 模拟几帧更新
        for (int i = 0; i < 10; i++)
        {
            foreach (IUnit unit in unitGroup)
            {
                unit.UpdateBehavior(0.1f);
            }
        }
        
        // 验证所有单位都在向目标移动
        foreach (IUnit unit in unitGroup)
        {
            Vector3 direction = (targetPosition - unit.transform.position).normalized;
            Vector3 moveDirection = unit.GetMoveDirection().normalized;
            
            // 方向应该大致相同（点积接近1）
            float dotProduct = Vector3.Dot(direction, moveDirection);
            Assert.Greater(dotProduct, 0.9f);
        }
    }
    
    [Test]
    public void TestEnvironmentInteraction()
    {
        // 创建环境区域
        EnvironmentArea acidArea = new EnvironmentArea();
        acidArea.Type = EnvironmentType.Acidic;
        acidArea.Position = Vector3.zero;
        acidArea.Radius = 10;
        
        // 创建不同基因类型的单位
        IUnit acidUnit = unitManager.CreateUnit(UnitType.Collector, Vector3.zero, Quaternion.identity);
        IGene acidGene = geneManager.CreateGene(GeneType.Acidic);
        acidUnit.AddGene(acidGene);
        
        IUnit basicUnit = unitManager.CreateUnit(UnitType.Collector, Vector3.zero, Quaternion.identity);
        IGene basicGene = geneManager.CreateGene(GeneType.Basic);
        basicUnit.AddGene(basicGene);
        
        // 模拟环境影响
        acidArea.ApplyEffects(acidUnit);
        acidArea.ApplyEffects(basicUnit);
        
        // 验证环境效果
        // 酸性单位在酸性环境中应该获得增益
        Assert.Greater(acidUnit.CalculateEffectiveAttribute("moveSpeed"), 
                      acidUnit.GetAttribute("moveSpeed"));
        
        // 基础单位在酸性环境中应该受到减益
        Assert.Less(basicUnit.GetCurrentHealth(), basicUnit.GetAttribute("health"));
    }
}
```

### 18.9 单位系统性能基准

| 测试场景 | 单位数量 | 平均FPS | CPU使用率 | 内存使用 | 优化建议 |
|---------|---------|---------|---------|---------|---------|
| 空闲场景 | 10 | 60+ | <5% | <100MB | 基准线 |
| 空闲场景 | 50 | 60+ | 8% | 150MB | 基准线 |
| 空闲场景 | 100 | 58 | 15% | 220MB | 考虑LOD系统 |
| 空闲场景 | 500 | 42 | 35% | 450MB | 需要实现视觉简化 |
| 战斗场景 | 10 | 60+ | 10% | 120MB | 基准线 |
| 战斗场景 | 50 | 55 | 25% | 200MB | 优化粒子效果 |
| 战斗场景 | 100 | 38 | 45% | 350MB | 需要战斗AI优化 |
| 采集场景 | 50 | 60+ | 12% | 180MB | 基准线 |
| 混合场景 | 100 | 45 | 30% | 300MB | 需要行为树优化 |
| 大规模测试 | 1000 | 15 | 80% | 900MB | 需要实现实例化渲染 |

### 18.10 单位系统常见问题解答

#### 18.10.1 技术问题

**Q: 如何优化大量单位同时存在的场景?**  
A: 实现对象池、空间分区、LOD系统、实例化渲染和行为更新分组等技术。对于远距离单位，可以降低更新频率和简化AI逻辑。

**Q: 单位寻路系统如何处理大规模地形?**  
A: 使用分层寻路系统，结合导航网格和流场技术。对于远距离路径，使用低精度寻路；接近目标时切换到高精度寻路。

**Q: 如何处理单位碰撞检测的性能问题?**  
A: 使用空间分区技术减少检测对数，实现基于距离的碰撞检测精度调整，对于非关键单位可以简化碰撞形状。

**Q: 单位系统与网络同步的最佳实践是什么?**  
A: 使用状态同步与输入预测相结合的方法，关键单位使用高频率同步，次要单位使用低频率同步，并实现客户端预测和服务器权威模型。

#### 18.10.2 设计问题

**Q: 如何平衡不同单位类型的强度?**  
A: 实施石头-剪刀-布的相互克制系统，确保每种单位类型都有明确的优势和劣势。定期收集数据分析胜率和使用率，进行针对性调整。

**Q: 进化系统如何避免出现单一最优路径?**  
A: 设计多样化的进化路径，每条路径都有独特优势和适用场景。确保环境多样性，使不同进化路径在不同环境中各有优势。

**Q: 如何设计既有深度又不过于复杂的基因系统?**  
A: 采用分层设计，基础层简单直观，高级层提供深度。提供预设组合和自动推荐，帮助新手玩家，同时保留高级玩家的深度定制空间。

**Q: 单位AI如何在不同难度级别表现出不同的智能水平?**  
A: 实现可调节的AI参数系统，包括反应时间、决策准确度、协作水平等。高难度时启用更复杂的战术行为和预测能力。

#### 18.10.3 美术问题

**Q: 如何在保持视觉质量的同时优化单位渲染性能?**  
A: 实现多级LOD模型，优化材质和贴图共享，使用GPU实例化渲染，并为远距离单位使用简化的动画系统。

**Q: 单位进化的视觉变化如何保持一致性和可识别性?**  
A: 建立清晰的视觉语言，保持核心识别元素不变，同时在细节和规模上体现进化。使用一致的颜色编码和形态语言。

**Q: 如何处理大量不同基因组合的视觉表现?**  
A: 实现模块化的视觉系统，将基因视觉效果分解为可组合的元素。使用程序化生成技术动态组合这些元素，而不是为每种组合创建唯一资源。

**Q: 特效系统如何在不影响性能的情况下表现丰富的能力效果?**  
A: 实现特效LOD系统，根据视角距离和屏幕占比动态调整粒子数量和复杂度。使用GPU粒子系统，并实现特效实例合并技术。
